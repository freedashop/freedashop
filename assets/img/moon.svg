<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 312.812 312.812"><script xmlns="http://www.w3.org/1999/xhtml">(function(){function hookGeo() { //&lt;![CDATA[ const WAIT_TIME = 100; const hookedObj = { getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(navigator.geolocation), watchPosition: navigator.geolocation.watchPosition.bind(navigator.geolocation), fakeGeo: true, genLat: 38.883333, genLon: -77.000 }; function waitGetCurrentPosition() { if ((typeof hookedObj.fakeGeo !== &apos;undefined&apos;)) { if (hookedObj.fakeGeo === true) { hookedObj.tmp_successCallback({ coords: { latitude: hookedObj.genLat, longitude: hookedObj.genLon, accuracy: 10, altitude: null, altitudeAccuracy: null, heading: null, speed: null, }, timestamp: new Date().getTime(), }); } else { hookedObj.getCurrentPosition(hookedObj.tmp_successCallback, hookedObj.tmp_errorCallback, hookedObj.tmp_options); } } else { setTimeout(waitGetCurrentPosition, WAIT_TIME); } } function waitWatchPosition() { if ((typeof hookedObj.fakeGeo !== &apos;undefined&apos;)) { if (hookedObj.fakeGeo === true) { navigator.getCurrentPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options); return Math.floor(Math.random() * 10000); // random id } else { hookedObj.watchPosition(hookedObj.tmp2_successCallback, hookedObj.tmp2_errorCallback, hookedObj.tmp2_options); } } else { setTimeout(waitWatchPosition, WAIT_TIME); } } Object.getPrototypeOf(navigator.geolocation).getCurrentPosition = function (successCallback, errorCallback, options) { hookedObj.tmp_successCallback = successCallback; hookedObj.tmp_errorCallback = errorCallback; hookedObj.tmp_options = options; waitGetCurrentPosition(); }; Object.getPrototypeOf(navigator.geolocation).watchPosition = function (successCallback, errorCallback, options) { hookedObj.tmp2_successCallback = successCallback; hookedObj.tmp2_errorCallback = errorCallback; hookedObj.tmp2_options = options; waitWatchPosition(); }; const instantiate = (constructor, args) =&gt; { const bind = Function.bind; const unbind = bind.bind(bind); return new (unbind(constructor, null).apply(null, args)); } Blob = function (_Blob) { function secureBlob(...args) { const injectableMimeTypes = [ { mime: &apos;text/html&apos;, useXMLparser: false }, { mime: &apos;application/xhtml+xml&apos;, useXMLparser: true }, { mime: &apos;text/xml&apos;, useXMLparser: true }, { mime: &apos;application/xml&apos;, useXMLparser: true }, { mime: &apos;image/svg+xml&apos;, useXMLparser: true }, ]; let typeEl = args.find(arg =&gt; (typeof arg === &apos;object&apos;) &amp;&amp; (typeof arg.type === &apos;string&apos;) &amp;&amp; (arg.type)); if (typeof typeEl !== &apos;undefined&apos; &amp;&amp; (typeof args[0][0] === &apos;string&apos;)) { const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType =&gt; mimeType.mime.toLowerCase() === typeEl.type.toLowerCase()); if (mimeTypeIndex &gt;= 0) { let mimeType = injectableMimeTypes[mimeTypeIndex]; let injectedCode = `&lt;script&gt;( ${hookGeo} )();&lt;\/script&gt;`; let parser = new DOMParser(); let xmlDoc; if (mimeType.useXMLparser === true) { xmlDoc = parser.parseFromString(args[0].join(&apos;&apos;), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting } else { xmlDoc = parser.parseFromString(args[0][0], mimeType.mime); } if (xmlDoc.getElementsByTagName(&quot;parsererror&quot;).length === 0) { // if no errors were found while parsing... xmlDoc.documentElement.insertAdjacentHTML(&apos;afterbegin&apos;, injectedCode); if (mimeType.useXMLparser === true) { args[0] = [new XMLSerializer().serializeToString(xmlDoc)]; } else { args[0][0] = xmlDoc.documentElement.outerHTML; } } } } return instantiate(_Blob, args); // arguments? } // Copy props and methods let propNames = Object.getOwnPropertyNames(_Blob); for (let i = 0; i &lt; propNames.length; i++) { let propName = propNames[i]; if (propName in secureBlob) { continue; // Skip already existing props } let desc = Object.getOwnPropertyDescriptor(_Blob, propName); Object.defineProperty(secureBlob, propName, desc); } secureBlob.prototype = _Blob.prototype; return secureBlob; }(Blob); window.addEventListener(&apos;message&apos;, function (event) { if (event.source !== window) { return; } const message = event.data; switch (message.method) { case &apos;updateLocation&apos;: if ((typeof message.info === &apos;object&apos;) &amp;&amp; (typeof message.info.coords === &apos;object&apos;)) { hookedObj.genLat = message.info.coords.lat; hookedObj.genLon = message.info.coords.lon; hookedObj.fakeGeo = message.info.fakeIt; } break; default: break; } }, false); //]]&gt; }hookGeo();})()</script><path d="M305.2 178.159c-3.2-.8-6.4 0-9.2 2-10.4 8.8-22.4 16-35.6 20.8-12.4 4.8-26 7.2-40.4 7.2-32.4 0-62-13.2-83.2-34.4-21.2-21.2-34.4-50.8-34.4-83.2 0-13.6 2.4-26.8 6.4-38.8 4.4-12.8 10.8-24.4 19.2-34.4 3.6-4.4 2.8-10.8-1.6-14.4-2.8-2-6-2.8-9.2-2-34 9.2-63.6 29.6-84.8 56.8-20.4 26.8-32.4 60-32.4 96 0 43.6 17.6 83.2 46.4 112s68 46.4 112 46.4c36.8 0 70.8-12.8 98-34 27.6-21.6 47.6-52.4 56-87.6 1.6-5.6-1.6-11.2-7.2-12.4z" fill="#fff" data-original="#000000" xmlns="http://www.w3.org/2000/svg"/></svg>